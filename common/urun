#!/usr/bin/env python

import os,optparse,sys,types
import signal

try:
    import resource
except ImportError:
    resource = None

class urun:
    # serial
    cmd_serial = "%(prog)s *"

    # omp
    cmd_omp = "%(prog)s *"
    env_g_omp = "OMP_NUM_THREADS=%(ppn)s"
    env_i_omp = env_g_omp
    env_im_omp = env_g_omp
    if not os.environ.has_key("OMP_PROC_BIND"):
        env_g_omp += " OMP_PROC_BIND=true"
    if not os.environ.has_key("KMP_AFFINITY"):
        env_i_omp += " KMP_AFFINITY=scatter"
        env_im_omp += " KMP_AFFINITY=scatter"
        
    # tbb
    cmd_tbb = "%(prog)s *"
    env_tbb = "TBB_NTHREADS=%(ppn)s"

    # cilk
    cmd_cilk = "%(prog)s --nproc %(ppn)s *"
    cmd_cilkplus = "%(prog)s *"
    env_cilkplus = "CILK_NWORKERS=%(ppn)s"

    # mth
    cmd_mth = "%(prog)s *"
    env_mth = ("MYTH_WORKER_NUM=%(ppn)s "
               "MYTH_DEF_STKSIZE=%(stack_size)s "
               "MYTH_CPU_LIST=%(myth_cpu_list)s")

    # mthpth
    cmd_mthpth = "%(prog)s *"
    env_mthpth = ("MYTH_WORKER_NUM=%(ppn)s "
                  "MYTH_DEF_STKSIZE=%(stack_size)s "
                  "MYTH_CPU_LIST=%(myth_cpu_list)s")
    # qth
    cmd_qth = "%(prog)s *"
    env_qth = ("QTHREAD_NUM_WORKERS_PER_SHEPHERD=%(qthread_num_workers_per_shepherd)s "
               "QTHREAD_NUM_SHEPHERDS=%(ppn)s "
               "QTHREAD_STACK_SIZE=%(stack_size)s")
    # nanox
    cmd_nanox = "%(prog)s *"
    env_nanox = ("NX_PES=%(ppn)s "
                 "NX_SCHEDULE=%(nx_schedule)s")
    # pth
    cmd_pth = "%(prog)s *"
    env_pth = "PTH_NTHREADS=%(ppn)s"
    # mpi
    cmd_mpi = "%(mpi)s -n %(nodes_ppn)s %(prog)s *"
    # upc
    cmd_upc = "%(upcrun)s -n %(nodes_ppn)s -pthreads %(ppn)s %(prog)s *"
    env_upc = [ 'MPIRUN_CMD="%(mpi_upc)s -n %%N %%C"' ]
    # chpl
    cmd_chpl = ("%(mpi_chpl)s -n %(nodes)d %(prog)s * "
                "-nl $(nodes)s --dataParTasksPerLocale %(ppn)s")
    # x10
    cmd_x10 = "%(mpi_x10)s -n %(nodes)s %(prog)s *"
    env_x10 = ("X10_NTHREADS=%(ppn)s "
               "X10_STATIC_THREADS=1")


def Ws(s):
    sys.stdout.write(s)
    sys.stdout.flush()

def Es(s):
    sys.stderr.write(s)

# -------- read proc cpu info and suggest cpu order ------------

def safe_int(x):
    try:
        return int(x)
    except ValueError:
        return x

def read_proc_cpuinfo(cpuinfo):
    """
    read a file (/proc/cpuinfo) and make a database
    of cpus.  e.g., from a string like:

    processor	: 149
    vendor_id	: GenuineIntel
    cpu family	: 11
    model		: 1

    we create a dictionary 
    { "processor" : "149", "vendor_id" : "GenuineIntel", ... }

    we create such a dictionary for each cpu.

    return value is a list of dictionaries.

    """
    fp = open(cpuinfo, "rb")
    all_cpus = []
    cur_cpu = {}
    for line in fp:
        s_line = line.strip()
        if s_line == "":
            all_cpus.append(cur_cpu)
            cur_cpu = {}
        else:
            [ a,b ] = s_line.split(":", 1)
            cur_cpu[a.strip()] = safe_int(b.strip())
    assert (len(cur_cpu) == 0), cur_cpu
    return all_cpus

def xgroup_by(records, key):
    groups = {}
    for record in records:
        if not groups.has_key(record[key]):
            groups[record[key]] = []
        groups[record[key]].append(record)
    return groups

def group_by(records, keys):
    groups = {}
    for record in records:
        vals = tuple([ record[k] for k in keys ])
        if not groups.has_key(vals):
            groups[vals] = []
        groups[vals].append(record)
    return groups

def scatter_cpu():
    """
    return the list of cpu ids, so that any prefix
    of it scatters cpus among cores
    """
    info = read_proc_cpuinfo("/proc/cpuinfo")
    group_by_core = group_by(info, ("physical id","core id"))
    all_cpus = []
    for (physical_id,core_id),cpus in sorted(group_by_core.items()):
        cpus.sort(key=lambda c: c["processor"])
        for i,cpu in enumerate(cpus):
            all_cpus.append((i, core_id, cpu["processor"]))
    all_cpus.sort()
    return [ x for _,_,x in all_cpus ]

def list_to_string_simple(cpus):
    return ",".join([ ("%d" % cpu) for cpu in cpus ])

def stride_to_string(start, last, stride):
    if stride is None:
        return ("%d" % start)
    elif start + stride == last:
        return ("%d,%d" % (start, last))
    elif stride == 1:
        return ("%d-%d" % (start, last+1))
    else:
        return ("%d-%d:%d" % (start, last+stride, stride))

def list_to_string(X):
    start = None
    last = None
    stride = None
    # start = None <-> 0 elements in current set
    # start != None, stride = None <-> 1 element in current set
    # start != None, stride != None <-> 1 element in current set
    # start,start+stride,start+2*stride,...,last
    A = []
    for x in X:
        if start is None:
            start = x
        elif stride is None:
            stride = x - start
        elif last + stride != x:
            A.append(stride_to_string(start, last, stride))
            start = x
            stride = None
        last = x
    if start is not None: 
        A.append(stride_to_string(start, last, stride))
    return ",".join(A)


def parse_opts():
    usage = "usage: %prog [options] -- your program's command line args ... "
    ps = optparse.OptionParser(usage=usage)
    ps.add_option("-n", "--nodes", dest="nodes", 
                  type="int", default=1,
                  help="set node count to N (default: 1)", 
                  metavar="N")
    ps.add_option("-p", "--ppn", "--process-per-node", dest="ppn", 
                  type="int", default=1,
                  help="set process per node P (default: 1)", 
                  metavar="P")
    ps.add_option("-t", "--type", dest="program_type", 
                  type="string", default="",
                  help=("set program type to T "
                        "(default: derive from program name)"), 
                  metavar="T")
    ps.add_option("-f", "--platform", dest="platform_type", 
                  type="string", default="",
                  help=("set platform type to T "
                        "(default: derive from program name)"), 
                  metavar="F")
    ps.add_option("-x", "--cpu-limit", dest="cpu_limit", 
                  type="float", default=0,
                  help="set cpu limit to X sec (default: 0, meaning no limit)", 
                  metavar="X")
    ps.add_option("-w", "--walltime-limit", dest="walltime_limit", 
                  type="int", default=0,
                  help="set walltime limit to W sec (default: 0, meaning no limit)", 
                  metavar="W")
    ps.add_option("--mpi", dest="mpi",
                  type="string", default="mpiexec",
                  help="set mpirun/exec to launch mpi to PATH (default: mpiexec)", 
                  metavar="PATH")
    ps.add_option("--mpi_chpl", dest="mpi_chpl",
                  type="string", default="mpiexec",
                  help="set mpirun/exec to launch chapel to PATH (default: mpiexec)", 
                  metavar="PATH")
    ps.add_option("--mpi_x10", dest="mpi_x10",
                  type="string", default="mpiexec",
                  help="set mpirun/exec to launch X10 to PATH (default: mpiexec)", 
                  metavar="PATH")
    ps.add_option("--mpi_upc", dest="mpi_upc",
                  type="string", default="mpiexec",
                  help="set mpirun/exec to launch UPC to PATH (default: mpiexec)",
                  metavar="PATH")
    ps.add_option("--upcrun", dest="upcrun",
                  type="string", default="upcrun",
                  help="set upcrun to launch UPC to PATH (default: upcrun)", 
                  metavar="PATH")
    ps.add_option("--stack_size", dest="stack_size",
                  type="int", default=131072,
                  help="set qthreads/massivethreads stack size to S bytes (default: 131072)", 
                  metavar="S")
    ps.add_option("--qthread_num_workers_per_shepherd", 
                  dest="qthread_num_workers_per_shepherd",
                  type="int", default=1,
                  help="set qthreads workers per shepherd to N (default: 1)", 
                  metavar="N")
    # from 2013-06-14, cilk scheduler in nanox disappered
    ps.add_option("--nx_schedule", dest="nx_schedule",
                  type="string", default="wf",
                  help="set nanox scheduler to S (default: wf)",
                  metavar="S")
    ps.add_option("--myth_cpu_list", dest="myth_cpu_list",
                  type="string", default=None,
                  help="set myth_cpu_list",
                  metavar="S")
    ps.add_option("--dryrun", dest="dryrun",
                  action="store_true",
                  help="when given, only show the command and exit")
    ps.add_option("--resource", dest="resource",
                  action="store_true",
                  help="when given, show resource usage of the command")
    ps.add_option("-q", "--quiet", dest="quiet",
                  action="store_true",
                  help="when given, do not show the command to execute")
    ps.add_option("--more_help", dest="more_help",
                  action="store_true", default=0,
                  help="when given, show examples and exit (default: not)")
    return ps.parse_args()
    
def validate_and_set_defaults(options, args):
    D = options.__dict__.copy()
    D["nodes_ppn"] = D["nodes"] * D["ppn"]
    if len(args) == 0:
        Es("error: no program given\n")
        return None,None
    prog = args[0]
    D["prog"] = prog
    if D["program_type"] == "" or D["platform_type"] == "":
        x = prog.split("_")
        if len(x) <= 2:
            Es("error: cannot infer program type and platform type (either --type or --platform is not given or cannot be infered from the program name (%s)\n" % prog)
            return None,None
        else:
            if D["program_type"] == "":
                D["program_type"] = x[-1]
            if D["platform_type"] == "":
                D["platform_type"] = x[-2]
    if D["myth_cpu_list"] is None:
        D["myth_cpu_list"] = list_to_string(scatter_cpu())
    return D,args

def create_cmd_and_env(opts, args):
    prog = opts["program_type"]
    plat = opts["platform_type"]
    cmd_plat_prog_key = "cmd_%s_%s" % (plat, prog)
    env_plat_prog_key = "env_%s_%s" % (plat, prog)
    cmd_prog_key = "cmd_%s" % prog
    env_prog_key = "env_%s" % prog
    if hasattr(urun, cmd_plat_prog_key):
        cmd = getattr(urun, cmd_plat_prog_key)
    elif hasattr(urun, cmd_prog_key):
        cmd = getattr(urun, cmd_prog_key)
    else:
        Es("error: program type %s not supported\n" % prog)
        return None,None
    if hasattr(urun, env_plat_prog_key):
        env = getattr(urun, env_plat_prog_key)
    elif hasattr(urun, env_prog_key):
        env = getattr(urun, env_prog_key)
    else:
        env = ""
    # now substitute options for placeholders
    if type(cmd) is types.StringType:
        # if it's a string, assume it is a space-separated
        cmd_l = cmd.split()
    elif type(cmd) is types.ListType:
        cmd_l = cmd
    else:
        Es("error: command template is either a string or a list\n")
        return None,None
    # cmd_l is nearly it, but we replace "*" with the real args
    cmd_list = []
    for x in cmd_l:
        if x == "*":
            cmd_list.extend(args[1:])
        else:
            cmd_list.append(x % opts)
    if type(env) is types.StringType:
        env_list = env.split()
    elif type(env) is types.ListType:
        env_list = env
    else:
        Es("error: environment template is either a string or a list\n")
        return None,None
    env_list = [ x % opts for x in env_list ]
    env_dict = {}
    for e in env_list:
        if "=" not in e:
            Es("error: environment template (%s) has no '='\n" % e)
        x,v = e.split("=", 1)
        env_dict[x] = v
    return cmd_list,env_dict

def gethostname_by_socket():
    try:
        import socket
        gh = socket.gethostname
    except:
        return None
    return gh()

def gethostname_by_command():
    try:
        import commands
        gso = commands.getstatusoutput
    except:
        return None
    s,h = gso("hostname")
    if s == 0: return h

def gethostname():
    h = gethostname_by_socket()
    if h: return h
    h = gethostname_by_command()
    if h: return h
    return "???"

def show_opts(opts, args):
    hostname = gethostname()
    Ws("urun: program=%s type=%s nodes=%d ppn=%d host=%s\n" 
       % (args[0], opts["program_type"], opts["nodes"], opts["ppn"], hostname))

def show_env(env_dict):
    S = []
    for k,v in env_dict.items():
        S.append("%s=%s" % (k, v))
    return " ".join(S)

def show_cmd(cmd_list):
    S = []
    for a in cmd_list:
        if " " in a:
            S.append("'%s'" % a)
        else:
            S.append(a)
    return " ".join(S)

def show_resource_usage(r0, r1):
    Ws("urun: resource usage\n")
    for f in dir(r0):
        if f.startswith("ru_"):
            dx = getattr(r1, f) - getattr(r0, f)
            Ws("%s: %d\n" % (f, dx))

def signum_to_signame(n):
    import signal
    for s in dir(signal):
        if s.startswith("SIG"):
            if n == getattr(signal, s):
                return s
    return "unknown"

def show_and_run(cmd_list, env_dict, show, dryrun, show_resource, 
                 cpu_limit, walltime_limit):
    if show:
        e = show_env(env_dict)
        c = show_cmd(cmd_list)
        if e == "":
            Ws("urun: %s\n" % c)
        else:
            Ws("urun: %s %s\n" % (e, c))
    if not dryrun:
        env = os.environ
        for x,v in env_dict.items():
            env[x] = v
        if show_resource and resource is None:
            Es("warning: --resource option given but"
               " resource module not available (ignored)\n")
        if cpu_limit > 0 and resource is None:
            Es("warning: --cpu-limit option given but"
               " resource module not available (ignored)\n")
        if show_resource and resource:
            r0 = resource.getrusage(resource.RUSAGE_CHILDREN)
        else:
            r0 = None
        pid = os.fork()
        if pid == 0:
            if cpu_limit > 0 and resource:
                resource.setrlimit(resource.RLIMIT_CPU, (cpu_limit, -1))
            if walltime_limit > 0:
                signal.alarm(walltime_limit)
            try:
                os.execvpe(cmd_list[0], cmd_list, env)
            except Exception,e:
                Es("urun: could not exec %s %s\n" % (cmd_list, e.args))
            return os.EX_SOFTWARE
        else:
            _,status = os.waitpid(pid, 0)
            if show_resource and resource:
                r1 = resource.getrusage(resource.RUSAGE_CHILDREN)
            else:
                r1 = None
            if os.WIFEXITED(status):
                ret = os.WEXITSTATUS(status)
                Ws("urun: process exited with status %d\n" % ret)
            elif os.WIFSIGNALED(status):
                signum = os.WTERMSIG(status)
                Ws("urun: process died with signal %d (%s)\n" 
                   % (signum, signum_to_signame(signum)))
                ret = os.EX_SOFTWARE
            else:
                # don't know what to return
                ret = os.EX_SOFTWARE
            if r0 is not None:
                show_resource_usage(r0, r1)
            return ret

def show_full_help():
    Es(r"""Examples:
  %(prog)s --nodes=2 --ppn=3 -- ./othello_mpi -x 3 -y 4 -z 5
  %(prog)s --ppn=24          -- ./othello_cilk -x 3 -y 4 -z 5
""" % { "prog" : sys.argv[0] })

def main():
    options,args = parse_opts()
    if options.more_help:
        show_full_help()
        return 0
    opts,args = validate_and_set_defaults(options, args)
    if opts is None: return 1   # NG
    if not opts["quiet"]:
        show_opts(opts, args)
    cmd_list,env_dict = create_cmd_and_env(opts, args)
    if cmd_list is None: return 1    # NG
    if opts["dryrun"] or not opts["quiet"]:
        show = 1
    else:
        show = 0
    return show_and_run(cmd_list, env_dict, show, 
                        opts["dryrun"], opts["resource"], 
                        opts["cpu_limit"], opts["walltime_limit"])

if __name__ == "__main__":
    sys.exit(main())

